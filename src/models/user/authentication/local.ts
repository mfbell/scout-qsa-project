import { prop, instanceMethod } from 'typegoose';
import bcrypt from 'bcrypt';
import crypto from 'crypto';

// cryptography settings
const saltRounds = 16;
const randomByteLen = 24;
const expireIn = 3600000;

const required = true;
const unique = true;

export class Password {
  @prop({ required })
  hash?: string;
  @prop({ unique })
  resetHash?: string;
  @prop({ default: Date })
  resetExpires?: Date;

  @instanceMethod
  async set(password: string): Promise<void> {
    this.hash = await bcrypt.hash(password, saltRounds);
  }

  @instanceMethod
  async validate(password: string): Promise<boolean> {
    if (!this.hash) return false;
    return await bcrypt.compare(password, this.hash);
  }

  /**
   * Create new password reset token and invalidate old token if exists.
   * @returns password reset token string promise
   */
  @instanceMethod
  async createResetToken(): Promise<string> {
    this.resetExpires = new Date(Date.now() + expireIn);
    let token = await crypto.randomBytes(randomByteLen);
    this.resetHash = await bcrypt.hash(token, saltRounds);
    return token.toString('hex')
  }

  /**
   * Verify if a password reset token is valid for the user, 
   * if true invalidates the token.
   * @param token password reset token generated by this.createResetToken()
   * @returns boolean promise of the compare
   */
  @instanceMethod
  async verifyResetTokenAndInvalidate(token: string): Promise<boolean> {
    if (!this.resetHash || !this.resetExpires || new Date > this.resetExpires) {
      return false
    }
    let hash = await bcrypt.hash(token, saltRounds);
    let result = await bcrypt.compare(hash, this.resetHash);
    if (result) {
      this.resetHash = undefined;
      this.resetExpires = undefined;
    }
    return result
  };
}

